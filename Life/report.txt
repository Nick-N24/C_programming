Nicholas Newton nnewton2
Lab 7 Report

Explaining user interaction, indside header/function/program, how checked and scenes

Once the Makefile is called, an executable is created. If the user calls this executable with a second argument (a data file), the program will enter batch mode. If the data file does not exist, an error code will display and the program will end. If an existing file is called, the program will display the empty board, fill the board, and begin the continuous animation. If the program is called without a second argument, the program will enter interactive mode, the user will be able to add cells, remove cells, make the next step in the cell board, play the continuous loop animation, or quit the program.

The first part of the files is the header. lifefunc.h includes the function prototypes.

The function program is lifefunc.c, which is used when functions are called from the main code. It includes the necessary libraries and 6 functions.
- Initialize sets up a blank array of spaces that will be on the board at the start of the program.
- Functions addCell and delCell are nearly identical. They take in the current board array and entered row/column location specified by the user and execute a task. addCell makes the specified location in the array a 'X', while delCell makes the specified location a space.
- The update function refreshes the screen with the current board. It first uses the escape code to reset and clear the screen, then uses a for loop to print the top border. Next, the side borders and array values are printed in a nested for loop. Finally, another for loop is used to print the lower border. The function usleep is used to delay the next step afterwards. The bottom does print, but it does not always seem like it appears until afterwards, which could be an issue with usleep.
- The last two functions are used together. step is the function that iterates the board each time according to the specified rules. It uses the function live_test to see what state each cell is in. live_test returns a 1 if the cell it is looking at in the array is a X. If it is on the border or otherwise, the function will return a 0. This can be used to count the number of live neighbors around a cell. In step, a nested for loop is used to go through each value in the array and check its condition with its neighbors. live_test is used on the 8 neighboring cells where live cells returning a 1 will count towards the total living neighbors. This is broken in the the above row of 3 cells, the two adjecent cells in the same row, and the bottom row of 3 cells, then combined to become the variable n_count. If the location of the cell being tested is living and has two neighbors, it will be living. If the cell tested has 3 neighbors, it will also be considered living. to note this as the function is still iterating through the entire array, this information is copied onto the 'copy' array board. Once each cell is evaluated, the copy array information is transferred to the current board array using a nested for loop.

The main function begins also noting argc and argv. This allows the program to see right away if it should go into batch or interactive mode. main first initializes present board (pboard) that is 40x40 with the global variable BOARD. It passes this array into the initalize function to make the array of spaces. A file pointer f is then created as well as conditionals used later called mode, quit, and infinite. When the program is entered, if argc is greater than one, then this means a datafile should be opened for batch mode. Mode will be set to 1 for batch mode in this if condition and the pointer f will fopen the called file from argv[1] to read. This condition also accounts for an invalid file name, which will end the program. If the argc is less than or equal to 1, the mode will be set to 2, which is interactive mode. Pointer f will be set to standard input, stdin. Because the program will not directly enter the continuous loop, the update function is called to display the loop and a print statement prompts the user to enter a command. The file pointer was created so fscanf could be used in both cases later in the respective while loops for batch and interactive.
Interactive mode activates if the mode set is 2. Then a while loop will run until the user decides to quit or run the simulation. The line array is created for the program to store the user input as information is scanned in. Once the first letter is scanned, the scan will stop by the space separator entered by the user. The program then runs through switch statements based on the first letter entered. When a or d is entered, it will then scan in the next two numbers and store them as the row(r) and column(c) values respectively. Case 'a' will then call the addCell function and case r will call the delCell function. Case n immediately calls the step function to iterate the next step in the life according to the rules. Case 'p' plays the infinite simulation. It sets the infinite to 1 and quit to 1. The infinite being set to true is used later to run the simulation while loop. When quit is set to 1, this makes the initial while condition !quit (which means while quit is false or 0) false so the loop will end. For case 'q,' quit is also set to 1, so the loop will end, but infinite would still be set to 0 so the infinite simulation loop will not run. There is also a default condition that will print if an invalid command is made by the user. After each iteration of this loop, the board is updated with the update function and the command prompt is reprinted. This will show the cells being added, removed, or iterated.

In Batch mode, it will begin the while loop when the mode is set to 1. This loop is similar to the interactive loop. The main difference is that the switch statement only includes case a and p, which would be the only things in the text files. Additionally, before the switch statement, there is a condition that will break the loop if the end of file character is read.

For the continuous simulation, it does not matter which mode the program is in. The mode is mainly used to figure out the intial inputs of the living cells. If interactive enters p, infinite is set to 1 and when the batch mode reads p from the file, infinite is set to 1. This is the while condition for the infinite loop. It continually steps, then updates the board using the step and update functions.

To check my work, I was able to check the intial parts when making sure the program recognized which mode it was in. After this, I used glider.txt to verify that the batch mode was running properly. Once I knew batch was working, I checked the interactive mode adding, deleting, and iterating cells. Then I was able to create my scenes, knowing they would properly move. For much of these scenes, I used the wiki link (1) provided for reference, as well as the game of life lexicon webpage (2). I also used a web-based game of life simulator(3) to test potential cell arrangements before figuring out their array locations. Scene 1 was relatively standard, which included the block, beehive, boat, and tub arrangements. These do not change. Next were the oscilating arrangements for scene 2 which 
i referenced thge blinker, toad, beacon, and penta decathalon configurations. Scene 3 asked to create moving cell patterns. I used the lexicon to refer to examples of spaceships and gliders to complete this task. I also realized that rotating a configuration would maintain the path, but change the direction it took. Scene 4 is an explosion that ends up as a solid relatively quickly. Lastly was scene 5. I chose this becasuse I though it looked relatively simple at first, but it was interesting how it changed so quickly. It also ended up oscilating between two large shapes.

Sources:
(1) general info   https://en.wikipedia.org/wiki/Conway's_Game_of_Life
(2) lexicon        https://playgameoflife.com/lexicon
(3) simulator      https://bitstorm.org/gameoflife/
